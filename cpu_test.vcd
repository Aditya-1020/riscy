$date
	Tue Oct 28 15:46:07 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module top_tb $end
$var wire 32 ! stall_count [31:0] $end
$var wire 32 " pc_if [31:0] $end
$var wire 32 # pc_id [31:0] $end
$var wire 32 $ instruction_if [31:0] $end
$var wire 32 % instruction_id [31:0] $end
$var wire 32 & instruction_count [31:0] $end
$var wire 1 ' icache_stall $end
$var wire 32 ( cycle_count [31:0] $end
$var wire 32 ) branch_mispredicts [31:0] $end
$var wire 1 * branch_mispredict $end
$var wire 32 + branch_count [31:0] $end
$var reg 1 , clk $end
$var reg 1 - reset $end
$scope module dut $end
$var wire 1 , clk $end
$var wire 32 . instruction_id [31:0] $end
$var wire 1 - reset $end
$var wire 32 / stall_count [31:0] $end
$var wire 32 0 pc_if_debug [31:0] $end
$var wire 32 1 pc_id_debug [31:0] $end
$var wire 1 2 is_store $end
$var wire 1 3 is_load $end
$var wire 1 4 is_jump $end
$var wire 1 5 is_jalr $end
$var wire 1 6 is_jal $end
$var wire 1 7 is_branch $end
$var wire 32 8 instruction_if_debug [31:0] $end
$var wire 32 9 instruction_id_debug [31:0] $end
$var wire 32 : instruction_count [31:0] $end
$var wire 1 ' icache_stall_signal $end
$var wire 32 ; cycle_count [31:0] $end
$var wire 32 < branch_mispredicts [31:0] $end
$var wire 1 * branch_mispredict_signal $end
$var wire 32 = branch_count [31:0] $end
$var wire 1 > branch $end
$var wire 1 ? RegWrite $end
$var wire 1 @ MemWrite $end
$var wire 1 A MemToReg $end
$var wire 1 B MemRead $end
$var wire 4 C ALU_op [3:0] $end
$var wire 1 D ALUSrc $end
$scope module control_unit_inst $end
$var wire 32 E instruction [31:0] $end
$var wire 7 F opcode [6:0] $end
$var wire 7 G funct7 [6:0] $end
$var wire 3 H funct3 [2:0] $end
$var wire 4 I decoded_funct7 [3:0] $end
$var reg 1 D ALUSrc $end
$var reg 4 J ALU_op [3:0] $end
$var reg 1 B MemRead $end
$var reg 1 A MemToReg $end
$var reg 1 @ MemWrite $end
$var reg 1 ? RegWrite $end
$var reg 1 > branch $end
$var reg 1 7 is_branch $end
$var reg 1 6 is_jal $end
$var reg 1 5 is_jalr $end
$var reg 1 4 is_jump $end
$var reg 1 3 is_load $end
$var reg 1 2 is_store $end
$scope module decode_inst $end
$var wire 7 K funct7 [6:0] $end
$var reg 4 L alu_op [3:0] $end
$upscope $end
$upscope $end
$scope module dp $end
$var wire 1 D ALUSrc_id $end
$var wire 4 M ALU_op_id [3:0] $end
$var wire 1 B MemRead_id $end
$var wire 1 A MemToReg_id $end
$var wire 1 @ MemWrite_id $end
$var wire 1 ? RegWrite_id $end
$var wire 32 N alu_in_a [31:0] $end
$var wire 1 > branch_id $end
$var wire 1 * branch_mispredict $end
$var wire 1 , clk $end
$var wire 1 O control_hazard $end
$var wire 1 P flush_ex $end
$var wire 1 Q flush_id $end
$var wire 1 R flush_if $end
$var wire 1 ' icache_stall $end
$var wire 32 S instruction_id_debug [31:0] $end
$var wire 32 T instruction_if_debug [31:0] $end
$var wire 1 7 is_branch_id $end
$var wire 1 6 is_jal_id $end
$var wire 1 5 is_jalr_id $end
$var wire 1 4 is_jump_id $end
$var wire 32 U pc_id_debug [31:0] $end
$var wire 32 V pc_if_debug [31:0] $end
$var wire 1 - reset $end
$var wire 1 W stall $end
$var wire 1 X use_ras_prediction $end
$var wire 4 Y write_enable_mem [3:0] $end
$var wire 32 Z write_back_data [31:0] $end
$var wire 5 [ rs2_id [4:0] $end
$var wire 32 \ rs2_data_mem [31:0] $end
$var wire 32 ] rs2_data_id [31:0] $end
$var wire 32 ^ rs2_data_ex [31:0] $end
$var wire 5 _ rs2_addr_ex [4:0] $end
$var wire 5 ` rs1_id [4:0] $end
$var wire 32 a rs1_data_id [31:0] $end
$var wire 32 b rs1_data_ex [31:0] $end
$var wire 5 c rs1_addr_ex [4:0] $end
$var wire 5 d rd_wb [4:0] $end
$var wire 5 e rd_mem [4:0] $end
$var wire 5 f rd_id [4:0] $end
$var wire 5 g rd_ex [4:0] $end
$var wire 1 h ras_valid $end
$var wire 32 i ras_top_addr [31:0] $end
$var wire 3 j ras_ptr [2:0] $end
$var wire 1 k prediction_if $end
$var wire 1 l prediction_id $end
$var wire 1 m prediction_ex $end
$var wire 32 n predicted_target_id [31:0] $end
$var wire 32 o predicted_target_ex [31:0] $end
$var wire 32 p predicted_pc_if [31:0] $end
$var wire 2 q predict_strength_if [1:0] $end
$var wire 32 r pc_plus4_if [31:0] $end
$var wire 32 s pc_next_if [31:0] $end
$var wire 32 t pc_if [31:0] $end
$var wire 32 u pc_id [31:0] $end
$var wire 32 v pc_hit_btb [31:0] $end
$var wire 32 w pc_ex [31:0] $end
$var wire 7 x opcode_id [6:0] $end
$var wire 7 y opcode_ex [6:0] $end
$var wire 32 z mem_read_data [31:0] $end
$var wire 32 { mem_data_wb [31:0] $end
$var wire 1 | load_use_stall $end
$var wire 2 } load_type_mem [1:0] $end
$var wire 1 ~ is_jalr_ex $end
$var wire 1 !" is_jal_ex $end
$var wire 1 "" is_branch_ex $end
$var wire 32 #" instruction_if [31:0] $end
$var wire 32 $" instruction_id [31:0] $end
$var wire 1 %" instr_30_id $end
$var wire 1 &" instr_30_ex $end
$var wire 32 '" immediate_id [31:0] $end
$var wire 32 (" immediate_ex [31:0] $end
$var wire 32 )" imem_instruction [31:0] $end
$var wire 1 *" icache_ready $end
$var wire 1 +" icache_miss $end
$var wire 1 ," icache_mem_req $end
$var wire 32 -" icache_mem_addr [31:0] $end
$var wire 1 ." icache_hit $end
$var wire 3 /" funct3_mem [2:0] $end
$var wire 3 0" funct3_id [2:0] $end
$var wire 3 1" funct3_ex [2:0] $end
$var wire 32 2" forwarded_rs2_ex [31:0] $end
$var wire 32 3" forwarded_rs1_ex [31:0] $end
$var wire 2 4" forward_b [1:0] $end
$var wire 2 5" forward_a [1:0] $end
$var wire 32 6" btb_target_if [31:0] $end
$var wire 1 7" btb_hit $end
$var wire 32 8" branch_target_ex [31:0] $end
$var wire 1 9" branch_taken_ex $end
$var wire 1 :" branch_ex $end
$var wire 1 ;" alu_zero_ex $end
$var wire 32 <" alu_result_wb [31:0] $end
$var wire 32 =" alu_result_mem [31:0] $end
$var wire 32 >" alu_result_ex [31:0] $end
$var wire 32 ?" alu_in_b [31:0] $end
$var wire 32 @" actual_next_pc_ex [31:0] $end
$var wire 1 A" RegWrite_wb $end
$var wire 1 B" RegWrite_mem $end
$var wire 1 C" RegWrite_ex $end
$var wire 1 D" MemWrite_mem $end
$var wire 1 E" MemWrite_ex $end
$var wire 1 F" MemToReg_wb $end
$var wire 1 G" MemToReg_mem $end
$var wire 1 H" MemToReg_ex $end
$var wire 1 I" MemRead_mem $end
$var wire 1 J" MemRead_ex $end
$var wire 4 K" ALU_op_ex [3:0] $end
$var wire 1 L" ALUSrc_ex $end
$scope module alu_inst $end
$var wire 32 M" a [31:0] $end
$var wire 32 N" b [31:0] $end
$var wire 32 O" signed_a [31:0] $end
$var wire 32 P" signed_b [31:0] $end
$var wire 5 Q" shift_amount [4:0] $end
$var wire 4 R" ALUControl [3:0] $end
$var reg 32 S" result [31:0] $end
$var reg 1 ;" zero $end
$upscope $end
$scope module bp_inst $end
$var wire 1 , clk $end
$var wire 1 T" predict_enable $end
$var wire 1 - reset $end
$var wire 4 U" update_index [3:0] $end
$var wire 1 :" update_enable $end
$var wire 1 k prediction $end
$var wire 2 V" predict_strength [1:0] $end
$var wire 4 W" predict_index [3:0] $end
$var wire 32 X" pc_update [31:0] $end
$var wire 32 Y" pc_if [31:0] $end
$var wire 1 "" is_branch $end
$var wire 1 9" branch_taken $end
$var integer 32 Z" i [31:0] $end
$upscope $end
$scope module branch_control_inst $end
$var wire 1 ;" alu_zero $end
$var wire 32 [" rs1_data [31:0] $end
$var wire 32 \" rs1_signed [31:0] $end
$var wire 32 ]" rs2_data [31:0] $end
$var wire 32 ^" rs2_signed [31:0] $end
$var wire 7 _" opcode [6:0] $end
$var wire 3 `" funct3 [2:0] $end
$var wire 1 :" branch_enable $end
$var reg 1 9" branch_taken $end
$upscope $end
$scope module btb_inst $end
$var wire 1 , clk $end
$var wire 1 a" hit $end
$var wire 1 7" hit_valid $end
$var wire 1 b" is_branch_or_jump $end
$var wire 1 c" lookup_enable $end
$var wire 1 - reset $end
$var wire 32 d" target_update [31:0] $end
$var wire 1 e" update_enable $end
$var wire 23 f" update_tag [22:0] $end
$var wire 4 g" update_index [3:0] $end
$var wire 32 h" target_predict [31:0] $end
$var wire 32 i" pc_update [31:0] $end
$var wire 32 j" pc_if [31:0] $end
$var wire 32 k" pc_hit [31:0] $end
$var wire 23 l" lookup_tag [22:0] $end
$var wire 4 m" lookup_index [3:0] $end
$var integer 32 n" i [31:0] $end
$upscope $end
$scope module data_memory_inst $end
$var wire 32 o" aligned_addr [31:0] $end
$var wire 1 , clk $end
$var wire 2 p" load_type [1:0] $end
$var wire 1 - reset $end
$var wire 4 q" wr_en [3:0] $end
$var wire 32 r" word_data [31:0] $end
$var wire 2 s" byte_offset [1:0] $end
$var wire 32 t" address [31:0] $end
$var wire 32 u" WriteData [31:0] $end
$var wire 1 I" MemRead $end
$var reg 32 v" ReadData [31:0] $end
$var integer 32 w" i [31:0] $end
$upscope $end
$scope module ex_mem_reg_inst $end
$var wire 32 x" alu_result_in [31:0] $end
$var wire 1 9" branch_taken_in $end
$var wire 32 y" branch_target_in [31:0] $end
$var wire 1 , clk $end
$var wire 1 P flush $end
$var wire 1 - reset $end
$var wire 32 z" rs2_data_in [31:0] $end
$var wire 1 {" stall $end
$var wire 5 |" rd_addr_in [4:0] $end
$var wire 3 }" funct3_in [2:0] $end
$var wire 1 :" branch_in $end
$var wire 1 C" RegWrite_in $end
$var wire 1 E" MemWrite_in $end
$var wire 1 H" MemToReg_in $end
$var wire 1 J" MemRead_in $end
$var reg 1 I" MemRead_out $end
$var reg 1 G" MemToReg_out $end
$var reg 1 D" MemWrite_out $end
$var reg 1 B" RegWrite_out $end
$var reg 32 ~" alu_result_out [31:0] $end
$var reg 1 !# branch_out $end
$var reg 1 "# branch_taken_out $end
$var reg 32 ## branch_target_out [31:0] $end
$var reg 3 $# funct3_out [2:0] $end
$var reg 5 %# rd_addr_out [4:0] $end
$var reg 32 &# rs2_data_out [31:0] $end
$upscope $end
$scope module forwarding_unit_inst $end
$var wire 1 B" RegWrite_mem $end
$var wire 5 '# rd_mem [4:0] $end
$var wire 5 (# rs2_ex [4:0] $end
$var wire 5 )# rs1_ex [4:0] $end
$var wire 5 *# rd_wb [4:0] $end
$var wire 1 A" RegWrite_wb $end
$var reg 2 +# forward_a [1:0] $end
$var reg 2 ,# forward_b [1:0] $end
$upscope $end
$scope module hazard_unit_inst $end
$var wire 1 -# control_hazard $end
$var wire 1 P flush_ex $end
$var wire 1 .# hazard_rs1 $end
$var wire 1 /# hazard_rs2 $end
$var wire 1 0# jump_in $end
$var wire 1 1# load_use_hazard $end
$var wire 5 2# rs1_id_in [4:0] $end
$var wire 5 3# rs2_id_in [4:0] $end
$var wire 1 | stall $end
$var wire 5 4# rd_ex_in [4:0] $end
$var wire 1 :" branch_in $end
$var wire 1 J" MemRead_in $end
$upscope $end
$scope module icache_inst $end
$var wire 1 , clk $end
$var wire 1 5# fetch_en $end
$var wire 1 6# mem_ready $end
$var wire 2 7# refill_word_offset [1:0] $end
$var wire 1 - reset $end
$var wire 1 8# tag_match $end
$var wire 2 9# word_offset [1:0] $end
$var wire 23 :# tag_in [22:0] $end
$var wire 5 ;# refill_index [4:0] $end
$var wire 32 <# pc [31:0] $end
$var wire 32 =# mem_data [31:0] $end
$var wire 5 ># index [4:0] $end
$var parameter 2 ?# IDLE $end
$var parameter 2 @# REFILL $end
$var reg 1 ." hit $end
$var reg 32 A# instruction [31:0] $end
$var reg 32 B# mem_addr [31:0] $end
$var reg 1 ," mem_read $end
$var reg 1 +" miss $end
$var reg 2 C# next_refill_count [1:0] $end
$var reg 2 D# next_state [1:0] $end
$var reg 1 *" ready $end
$var reg 2 E# refill_count [1:0] $end
$var reg 2 F# state [1:0] $end
$var integer 32 G# i [31:0] $end
$upscope $end
$scope module id_ex_reg_inst $end
$var wire 1 D ALUSrc_in $end
$var wire 4 H# ALU_op_in [3:0] $end
$var wire 1 I# MemRead_in $end
$var wire 1 J# MemToReg_in $end
$var wire 1 K# MemWrite_in $end
$var wire 1 L# RegWrite_in $end
$var wire 1 M# branch_in $end
$var wire 1 , clk $end
$var wire 1 Q flush $end
$var wire 3 N# funct3_in [2:0] $end
$var wire 1 %" instr_30_in $end
$var wire 1 7 is_branch_in $end
$var wire 1 6 is_jal_in $end
$var wire 1 5 is_jalr_in $end
$var wire 7 O# opcode_in [6:0] $end
$var wire 5 P# rd_addr_in [4:0] $end
$var wire 1 - reset $end
$var wire 5 Q# rs1_addr_in [4:0] $end
$var wire 5 R# rs2_addr_in [4:0] $end
$var wire 1 S# stall $end
$var wire 32 T# rs2_data_in [31:0] $end
$var wire 32 U# rs1_data_in [31:0] $end
$var wire 1 l prediction_in $end
$var wire 32 V# predicted_target_in [31:0] $end
$var wire 32 W# pc_in [31:0] $end
$var wire 32 X# immediate_in [31:0] $end
$var reg 1 L" ALUSrc_out $end
$var reg 4 Y# ALU_op_out [3:0] $end
$var reg 1 J" MemRead_out $end
$var reg 1 H" MemToReg_out $end
$var reg 1 E" MemWrite_out $end
$var reg 1 C" RegWrite_out $end
$var reg 1 :" branch_out $end
$var reg 3 Z# funct3_out [2:0] $end
$var reg 32 [# immediate_out [31:0] $end
$var reg 1 &" instr_30_out $end
$var reg 1 "" is_branch_out $end
$var reg 1 !" is_jal_out $end
$var reg 1 ~ is_jalr_out $end
$var reg 7 \# opcode_out [6:0] $end
$var reg 32 ]# pc_out [31:0] $end
$var reg 32 ^# predicted_target_out [31:0] $end
$var reg 1 m prediction_out $end
$var reg 5 _# rd_addr_out [4:0] $end
$var reg 5 `# rs1_addr_out [4:0] $end
$var reg 32 a# rs1_data_out [31:0] $end
$var reg 5 b# rs2_addr_out [4:0] $end
$var reg 32 c# rs2_data_out [31:0] $end
$upscope $end
$scope module if_id_reg_inst $end
$var wire 1 , clk $end
$var wire 1 R flush $end
$var wire 32 d# instruction_in [31:0] $end
$var wire 32 e# predicted_target_in [31:0] $end
$var wire 1 k prediction_in $end
$var wire 1 - reset $end
$var wire 1 W stall $end
$var wire 32 f# pc_in [31:0] $end
$var reg 32 g# instruction_out [31:0] $end
$var reg 32 h# pc_out [31:0] $end
$var reg 32 i# predicted_target_out [31:0] $end
$var reg 1 l prediction_out $end
$upscope $end
$scope module imem_inst $end
$var wire 10 j# address [9:0] $end
$var wire 1 , clk $end
$var wire 1 - reset $end
$var reg 32 k# instruction [31:0] $end
$var integer 32 l# i [31:0] $end
$upscope $end
$scope module imm_gen_inst $end
$var wire 32 m# instruction [31:0] $end
$var wire 32 n# u_imm [31:0] $end
$var wire 32 o# s_imm [31:0] $end
$var wire 7 p# opcode [6:0] $end
$var wire 32 q# j_imm [31:0] $end
$var wire 32 r# i_imm [31:0] $end
$var wire 32 s# b_imm [31:0] $end
$var reg 32 t# immediate [31:0] $end
$upscope $end
$scope module mem_wb_reg_inst $end
$var wire 1 G" MemToReg_in $end
$var wire 1 B" RegWrite_in $end
$var wire 32 u# alu_result_in [31:0] $end
$var wire 1 , clk $end
$var wire 1 v# flush $end
$var wire 32 w# mem_data_in [31:0] $end
$var wire 5 x# rd_addr_in [4:0] $end
$var wire 1 - reset $end
$var wire 1 y# stall $end
$var reg 1 F" MemToReg_out $end
$var reg 1 A" RegWrite_out $end
$var reg 32 z# alu_result_out [31:0] $end
$var reg 32 {# mem_data_out [31:0] $end
$var reg 5 |# rd_addr_out [4:0] $end
$upscope $end
$scope module pc_inst $end
$var wire 1 , clk $end
$var wire 32 }# pc_next [31:0] $end
$var wire 1 - reset $end
$var reg 32 ~# pc [31:0] $end
$upscope $end
$scope module pc_plus4_inst $end
$var wire 32 !$ pc_in [31:0] $end
$var wire 32 "$ pc_plus4 [31:0] $end
$upscope $end
$scope module ras_inst $end
$var wire 1 , clk $end
$var wire 1 O flush $end
$var wire 1 #$ is_call $end
$var wire 1 $$ is_return $end
$var wire 7 %$ opcode [6:0] $end
$var wire 1 ~ pop_en $end
$var wire 1 &$ push_en $end
$var wire 5 '$ rd [4:0] $end
$var wire 1 - reset $end
$var wire 32 ($ return_addresss [31:0] $end
$var wire 5 )$ rs1 [4:0] $end
$var wire 3 *$ stack_ptr_out [2:0] $end
$var wire 32 +$ top_stack_address [31:0] $end
$var wire 1 h valid_ras $end
$var reg 3 ,$ stack_ptr [2:0] $end
$var integer 32 -$ i [31:0] $end
$upscope $end
$scope module register_inst $end
$var wire 1 , clk $end
$var wire 5 .$ rd [4:0] $end
$var wire 1 - reset $end
$var wire 5 /$ rs1_addr [4:0] $end
$var wire 5 0$ rs2_addr [4:0] $end
$var wire 1 A" wr_en $end
$var wire 32 1$ write_data [31:0] $end
$var wire 32 2$ rs2_data [31:0] $end
$var wire 32 3$ rs1_data [31:0] $end
$var integer 32 4$ i [31:0] $end
$upscope $end
$upscope $end
$scope module performance_counters_inst $end
$var wire 1 5$ branch_predict $end
$var wire 1 * branch_taken $end
$var wire 1 , clk $end
$var wire 1 6$ instruction_valid $end
$var wire 1 7 is_branch $end
$var wire 1 - reset $end
$var wire 1 ' stall $end
$var reg 32 7$ branch_count [31:0] $end
$var reg 32 8$ branch_mispredicts [31:0] $end
$var reg 32 9$ cycle_count [31:0] $end
$var reg 32 :$ instruction_count [31:0] $end
$var reg 32 ;$ stall_count [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b1 @#
b0 ?#
$end
#0
$dumpvars
b0 ;$
b0 :$
b0 9$
b0 8$
b0 7$
06$
05$
b100000 4$
b0 3$
b0 2$
b0 1$
b0 0$
b0 /$
b0 .$
b1000 -$
b0 ,$
b0 +$
b0 *$
b0 )$
b100 ($
b0 '$
0&$
b0 %$
0$$
0#$
b100 "$
b0 !$
b0 ~#
b100 }#
b0 |#
b0 {#
b0 z#
0y#
b0 x#
b0 w#
0v#
b0 u#
b0 t#
b0 s#
b0 r#
b0 q#
b10011 p#
b0 o#
b0 n#
b10011 m#
b10000000000 l#
b10010011 k#
b0 j#
b0 i#
b0 h#
b10011 g#
b0 f#
b100 e#
b10011 d#
b0 c#
b0 b#
b0 a#
b0 `#
b0 _#
b0 ^#
b0 ]#
b0 \#
b0 [#
b0 Z#
b0 Y#
b0 X#
b0 W#
b0 V#
b0 U#
b0 T#
0S#
b0 R#
b0 Q#
b0 P#
b10011 O#
b0 N#
0M#
1L#
0K#
0J#
0I#
b0 H#
b100000 G#
b0 F#
b0 E#
b1 D#
b0 C#
b0 B#
b10011 A#
b0 >#
b10010011 =#
b0 <#
b0 ;#
b0 :#
b0 9#
08#
b0 7#
16#
15#
b0 4#
b0 3#
b0 2#
01#
00#
0/#
0.#
0-#
b0 ,#
b0 +#
b0 *#
b0 )#
b0 (#
b0 '#
b0 &#
b0 %#
b0 $#
b0 ##
0"#
0!#
b0 ~"
b0 }"
b0 |"
0{"
b0 z"
b0 y"
b0 x"
b10000000000 w"
b0 v"
b0 u"
b0 t"
b0 s"
b0 r"
b0 q"
b0 p"
b0 o"
b10000 n"
b0 m"
b0 l"
b0 k"
b0 j"
b0 i"
b100 h"
b0 g"
b0 f"
0e"
b100 d"
1c"
0b"
0a"
b0 `"
b0 _"
b0 ^"
b0 ]"
b0 \"
b0 ["
b10000 Z"
b0 Y"
b0 X"
b0 W"
b10 V"
b0 U"
1T"
b0 S"
b0 R"
b0 Q"
b0 P"
b0 O"
b0 N"
b0 M"
0L"
b0 K"
0J"
0I"
0H"
0G"
0F"
0E"
0D"
0C"
0B"
0A"
b100 @"
b0 ?"
b0 >"
b0 ="
b0 <"
1;"
0:"
09"
b0 8"
07"
b100 6"
b0 5"
b0 4"
b0 3"
b0 2"
b0 1"
b0 0"
b0 /"
0."
b0 -"
0,"
1+"
0*"
b10010011 )"
b0 ("
b0 '"
0&"
0%"
b10011 $"
b10011 #"
0""
0!"
0~
b0 }
0|
b0 {
b0 z
b0 y
b10011 x
b0 w
b0 v
b0 u
b0 t
b100 s
b100 r
b10 q
b100 p
b0 o
b0 n
0m
0l
1k
b0 j
b0 i
0h
b0 g
b0 f
b0 e
b0 d
b0 c
b0 b
b0 a
b0 `
b0 _
b0 ^
b0 ]
b0 \
b0 [
b0 Z
b0 Y
0X
0W
b0 V
b0 U
b10011 T
b10011 S
0R
0Q
0P
0O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
b10011 F
b10011 E
1D
b0 C
0B
0A
0@
1?
0>
b0 =
b0 <
b0 ;
b0 :
b10011 9
b10011 8
07
06
05
04
03
02
b0 1
b0 0
b0 /
b10011 .
1-
0,
b0 +
0*
b0 )
b0 (
0'
b0 &
b10011 %
b10011 $
b0 #
b0 "
b0 !
$end
#5000
b10000000000 w"
b100000 4$
b100000 G#
b1000 -$
b10000 Z"
b10000 n"
1,
#10000
0,
#15000
b10000 n"
b10000 Z"
b1000 -$
b100000 G#
b100000 4$
b10000000000 w"
1,
